---
title: "wk5_practical"
output:
  html_document: default
  pdf_document: default
runtime: shiny
---
###Clear Memory First !!

```{r}
rm(list = ls()) #removes all objects from workspace 
gc() #clear memory
```

## plan
**1. Downloading data**

For the hotels and Airbnb figures
- London borough MSOAs (shp)
- Airbnbs (csv)
- Hotels (shp)
For the study area map
- Outline of the UK (shp)
- UK cities (shp)

**2. Setting the CRS and filtering**

- CRS for the boroughs: British National Grid (BNG)
- Filter hotels from the OSM data
- Filter equivalent Airbnbs  
  (e.g., room_type == "Entire home/apt" & availability_365 == 365)

**3. Joining and summing data**

- Join Airbnbs to MSOAs and count per MSOA
- Join Hotels to MSOAs and count per MSOA

**4. Making some maps**

- Map of Airbnbs
- Map of Hotels
- Combined comparison map

## CRS and filter
start with our OSM and Airbnb data which we need for our sub figures

```{r}
library(sf)
library(tidyverse)

# OSM data

OSM <- st_read("wk5_data/greater-london-251122-free/gis_osm_pois_free_1.shp")%>%
  st_transform(., 27700) %>%
  #select hotels only
  filter(fclass == 'hotel')
```
```{r}
# Airbnb data
Airbnb <- read_csv("wk5_data/listings.csv") %>%
  # longitude is considered x value here, latitude is y
  st_as_sf(., coords = c("longitude", "latitude"), 
                   crs = 4326) %>%
    st_transform(., 27700)%>%
    #select entire places that are available all year
    filter(room_type == 'Entire home/apt' & availability_365 =='365')


#London Borough data is already in 277000
Londonborough <- st_read("wk5_data/statistical-gis-boundaries-london/ESRI/London_Borough_Excluding_MHW.shp")%>%
  st_transform(., 27700)
```
load the data needed for our study area map:  
- World cities, filtering for Birmingham, London and Edinburgh  
- An outline of the UK  

```{r}
# load world cities
Worldcities <- st_read("wk5_data/World_Cities/World_Cities.shp") %>%
  st_transform(., 27700)
```
```{r}
# filter based on key cities
Worldcities2 <- Worldcities %>%
  filter(CNTRY_NAME=='United Kingdom'&
           Worldcities$CITY_NAME=='Birmingham'|
           Worldcities$CITY_NAME=='London'|
           Worldcities$CITY_NAME=='Edinburgh')

# load UK outline
UK_outline <- st_read("wk5_data/gadm41_GBR_shp/gadm41_GBR_0.shp")%>%
  st_transform(., 27700)
```
## join and sum
```{r}
Hotels <-  st_join(Londonborough, OSM)

Airbnbs <-  st_join(Londonborough, Airbnb)

head(Hotels)
```
```{r}
#group_by()创建临时组，如果您要打印数据，只需指定组数，它看起来将与以前相同
#summarise()采取小组并提供一个总结，这里是每个小组的计数
Hotels_sum <- Hotels %>%
  # we need to list the columns we want to keep in the summarise
  group_by(., GSS_CODE, NAME)%>%
  # for each group count the number of rows and store in a column called accomodation count.
  summarise(`Accomodation count` = n())

Airbnb_sum <- Airbnbs %>%
  group_by(., GSS_CODE, NAME)%>%
  summarise(`Accomodation count` = n())
```
```{r}
# the st_join data = 0 Hotels
Hotels %>%
  filter(NAME=="Barking and Dagenham")
```
```{r}
# the group by and summarise data = 1 Hotel!
Hotels_sum %>%
  filter(NAME=="Barking and Dagenham")
```
topology relationship  
- st_intersects(A, B)- A（行政区）是否与B（OSM）接触或重叠。  
返回行政区列表（33行）和每个行政区的酒店列表  
- st_contains(A, B)- A（自治市）是否包含B（OSM）  
返回行政区列表（33行）和每个行政区的酒店列表  
- st_within(A, B)-是B（OSM）内的A（自治市）。这是在问酒店里面的行政区  
返回酒店内的行政区列表，这会产生0的结果。如果我们翻转它，我们会得到一个结果但它将是酒店的长度（例如st_within(OSM, Londonborough)）。注意，st_within(A, B) == st_contains(B, A)  

```{r}
Hotels_example <-st_contains(Londonborough, OSM)

Hotels_example
#如果您以前使用过图形用户界面GIS，这与select by location（例如QGIS中的按位置选择）相同，使用dplyr的过滤器与select by attribute相同
```
```{r}
#按区来取该列表的长度
Accomodation_contained <- Londonborough%>%
  mutate(hotels_n = lengths(st_contains(., OSM)))%>%
  mutate(airbnbs_n = lengths(st_contains(., Airbnbs)))
```

```{r}
# the group by and summarise data = 1 Hotel!
Accomodation_contained %>%
  filter(NAME=="Barking and Dagenham")
```
##key advice
何时使用st_join()或拓扑关系   
st_join()链接两个空间对象的属性
```{r}
Hotels2 <-  st_join(OSM, Londonborough)
#连接相同几何形状的多边形或点
#London_data <-  st_join(London_borough_data1, London_borough_data2, join=st_equals)
```

##mapping
```{r}
remotes::install_github("r-tmap/tmap")
```
tmap works on the principle of:    
- loading your shape object with tm_shape() (here sf object, but it could be a raster)   
- setting the map layer (e.g. polygons (tm_polygons()), symbols (tm_symbols()),raster (tm_raster()), text (tm_text()), lines (tm_lines()) etc).   
- applying a derived function (e.g. border (tm_borders()), fill (tm_fill()), markers (tm_markers()).  

```{r}
library(tmap)

# change to "view" for an interactive map
tmap_mode("plot")
```

```{r}
# set the shape
tm1 <- tm_shape(Accomodation_contained) + 
  # set the map layer
  # try changing this to tm_symbols()
  tm_polygons("hotels_n",
              col = "black", lwd=0.5, lty="dashed",)

# plot the map
tm1
```
```{r}
#Here, where we have map layer (e.g tm_polyons()) the derived function (e.g. border colour) is within the map layer function.如果只想要边框
tm_no_map_layer <- tm_shape(Accomodation_contained) + 
  # there is no tm_polygons() if we just want the map with no spatial data
  tm_borders(col = "darkblue")

tm_no_map_layer
```
```{r}
tmap_mode("plot")
```
```{r}
# plot each map
tm1 <- tm_shape(Accomodation_contained) + 
  tm_polygons(fill ="hotels_n",
              col = "black", 
              lwd =0.5,
              lty="dashed",
              fill.chart = tm_chart_violin(),
              # above this was the same as before
              fill.scale = tm_scale_intervals(
                values="brewer.bu_pu",
                n=5,
                style="jenks"))

tm1
```
In the above code we have:  

- tm_scale_intervals() - used for numerical data  
- values - the values to use to style the map, here it’s blue from the colour brewer list. There are a number of options here. See the next code chunk.   
- n - the number of breaks to have   
- style - how to decide where to make the breaks. We have a lot of choice for this. See the interval scale reference. Jenks looks for the natural breaks in the data and is often used.   
- fill_chart() produces a summary of the mapped data with a violin plot, there are many options see the tmap chart vigette   

```{r}
#color option
#install.packages(c("shinyjs", "kableExtra", "colorblindcheck"))
#library(colorblindcheck)
cols4all::c4a_gui()
```
##complete map
```{r}
#set up our breaks to see which dataset has the greatest range
stats <- Accomodation_contained %>%
  st_drop_geometry() %>%
  dplyr::select(hotels_n, airbnbs_n) %>%  
  summarise(across(everything(), list(
    min = min,
    max = max,
    mean = mean,
    median = median,
    sd = sd
  )))
```
```{r}
#由于爱彼迎的范围最大，我们将用它来生成我们的breaks，并将其应用于两个数据集
#library(classInt)

```



